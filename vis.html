<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Polygon Visualizer</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js"
      }
    }
  </script>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      margin: 0; min-height: 100vh; display: flex; align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #f5f7fb, #d7dce5);
      color: #1f2933;
    }
    .wrapper {
      text-align: center; padding: 1.5rem; border-radius: 16px;
      background: rgba(255, 255, 255, 0.85);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.15);
      backdrop-filter: blur(10px);
    }
    h1 {
      margin-top: 0; font-weight: 600; letter-spacing: 0.04em;
    }
    .plots-wrapper {
      display: flex; gap: 1.5rem; align-items: center;
      justify-content: center;
    }
    .plot-container {
      position: relative; width: min(300px, 28vw); aspect-ratio: 1 / 1;
    }
    .canvas-container {
      border-radius: 16px; overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.08);
      background: #101827; width: 100%; height: 100%;
    }
    .bd-plot-container canvas, .da-plot-container .crosshair {
        position: absolute; top: 0; left: 0;
    }
    #da-canvas, #bd-canvas, #bd-overlay-canvas {
      border-radius: 16px; overflow: hidden;
    }
    canvas {
      width: 100%; height: 100%; display: block; cursor: crosshair;
    }
    .controls {
      margin-top: 1rem; display: flex; flex-direction: column;
      gap: 0.75rem; align-items: center;
    }
    .hint {
      margin: 0; max-width: 420px; font-size: 0.9rem; color: #475569;
    }
    .crosshair {
      pointer-events: none; background-color: rgba(0, 255, 0, 0.5);
      display: none;
    }
    .crosshair.x { height: 100%; width: 1px; }
    .crosshair.y { width: 100%; height: 1px; }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>Polygon Playground</h1>
    <div class="plots-wrapper">
      <div class="plot-container">
        <div class="canvas-container">
          <canvas id="vis-canvas"></canvas>
        </div>
      </div>
      <div class="plot-container da-plot-container">
        <canvas id="da-canvas"></canvas>
        <div class="crosshair x" id="crosshair-da-x"></div>
        <div class="crosshair y" id="crosshair-da-y"></div>
      </div>
       <div class="plot-container bd-plot-container">
        <canvas id="bd-canvas"></canvas>
        <canvas id="bd-overlay-canvas"></canvas>
      </div>
    </div>
    <div class="controls">
      <p class="hint">
        Drag a vertex to move it. Click an edge to create a new vertex.
        Click a vertex and press delete to remove it.
      </p>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';

    // --- Main Polygon Visualization Setup ---
    const canvas = document.getElementById('vis-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f172a);
    const camera = new THREE.OrthographicCamera(0, 1, 1, 0, -10, 10);
    camera.position.set(0, 0, 5);
    const backgroundPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1));
    backgroundPlane.position.set(0.5, 0.5, -1);
    backgroundPlane.renderOrder = -1;
    scene.add(backgroundPlane);

    // Regular n-gon centered at (cx, cy) with radius r and rotation rot
    function makeRegularPolygon(n, cx, cy, r, rot = 0) {
      const pts = [];
      for (let i = 0; i < n; i++) {
        const theta = rot + (i * 2 * Math.PI) / n;
        const x = cx + r * Math.cos(theta);
        const y = cy + r * Math.sin(theta);
        pts.push(new THREE.Vector2(x, y));
      }
      return pts;
    }    
    const polygon = makeRegularPolygon(6, 0.5, 0.5, 0.3, Math.PI / 6);

    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
    const line = new THREE.LineLoop(new THREE.BufferGeometry(), lineMaterial);
    scene.add(line);

    // --- Chord and Square Visualization Setup ---
    const chordMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const chordLine = new THREE.Line(new THREE.BufferGeometry(), chordMaterial);
    chordLine.visible = false;
    scene.add(chordLine);
    const squareMaterial = new THREE.LineBasicMaterial({
        color: 0xff0000, transparent: true, opacity: 0.5
    });
    const squareLine = new THREE.LineLoop(
        new THREE.BufferGeometry(), squareMaterial
    );
    squareLine.visible = false;
    scene.add(squareLine);
    const otherVertexGeometry = new THREE.RingGeometry(0.008, 0.012, 24);
    const otherVertexMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff, side: THREE.DoubleSide
    });
    const sqVtxB = new THREE.Mesh(otherVertexGeometry, otherVertexMaterial);
    const sqVtxD = new THREE.Mesh(otherVertexGeometry, otherVertexMaterial);
    sqVtxB.visible = false; sqVtxD.visible = false;
    scene.add(sqVtxB, sqVtxD);

    const vertexGeometry = new THREE.CircleGeometry(0.015, 24);
    const baseColor = new THREE.Color(0x3b82f6);
    const highlightColor = new THREE.Color(0xf97316);
    const vertexMeshes = [];

    let selectedVertexIndex = null;
    let isDragging = false;
    let totalPerimeter = 0;
    const segmentLengths = [];

    const MAX_VERTICES = 50;

    let bdDirty = true;

    function makeVec2Array(n) {
        const a = new Array(n);
        for (let i = 0; i < n; i++) a[i] = new THREE.Vector2(0, 0);
        return a;
    }
    function makeFloatArray(n) {
        const a = new Array(n);
        for (let i = 0; i < n; i++) a[i] = 0.0;
        return a;
    }

    const mainVertexShader = `
        varying vec2 v_uv;
        void main() {
            v_uv = uv;
            gl_Position = projectionMatrix * modelViewMatrix *
                vec4(position, 1.0);
        }`;
    const commonGlslFunctions = `
      float distanceToSegment(vec2 p, vec2 a, vec2 b) {
          vec2 ab = b - a;
          vec2 ap = p - a;
          float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);
          return distance(p, a + t * ab);
      }
      float signedDistance_glsl(vec2 p, vec2 poly[${MAX_VERTICES}],
                                int count) {
          if (count < 3) return 1.0;
          float minDst = 1e9;
          for (int i = 0; i < ${MAX_VERTICES}; ++i) {
              if (i >= count) break;
              vec2 p1 = poly[i];
              vec2 p2 = poly[int(mod(float(i) + 1.0, float(count)))];
              minDst = min(minDst, distanceToSegment(p, p1, p2));
          }
          const float PI = 3.1415926535;
          float totalAngle = 0.0;
          for (int i = 0; i < ${MAX_VERTICES}; ++i) {
              if (i >= count) break;
              vec2 v1 = poly[i] - p;
              vec2 v2 = poly[int(mod(float(i) + 1.0, float(count)))] - p;
              float a1 = atan(v1.y, v1.x);
              float a2 = atan(v2.y, v2.x);
              float dA = a2 - a1;
              if (dA > PI) dA -= 2.0 * PI;
              if (dA < -PI) dA += 2.0 * PI;
              totalAngle += dA;
          }
          return abs(totalAngle) > PI ? -minDst : minDst;
      }
      vec2 getPointAt_glsl(float t, vec2 poly[${MAX_VERTICES}], int count,
                           float segs[${MAX_VERTICES}], float totalPerim) {
          if (totalPerim == 0.0) return poly[0];
          float target = mod(t, 1.0) * totalPerim;
          for (int i = 0; i < ${MAX_VERTICES}; ++i) {
              if (i >= count) break;
              float segLen = segs[i];
              if (target <= segLen && segLen > 0.0) {
                  vec2 p1 = poly[i];
                  vec2 p2 = poly[int(mod(float(i) + 1.0, float(count)))];
                  return mix(p1, p2, target / segLen);
              }
              target -= segLen;
          }
          return poly[0];
      }`;
    const mainFragmentShader = `
      varying vec2 v_uv;
      uniform vec2 u_polygon[${MAX_VERTICES}];
      uniform int u_vertexCount;
      uniform vec3 u_colorInside;
      uniform vec3 u_colorOutside;
      uniform vec3 u_colorBoundary;
      uniform float u_rangeInside;
      uniform float u_rangeOutside;
      ${commonGlslFunctions}
      void main() {
          float sd = signedDistance_glsl(v_uv, u_polygon, u_vertexCount);
          vec3 finalColor;
          if (sd >= 0.0) {
              float t = smoothstep(0.0, u_rangeOutside, sd);
              finalColor = mix(u_colorBoundary, u_colorOutside, t);
          } else {
              float t = smoothstep(0.0, u_rangeInside, -sd);
              finalColor = mix(u_colorBoundary, u_colorInside, t);
          }
          gl_FragColor = vec4(finalColor, 1.0);
      }`;
    const mainShaderMaterial = new THREE.ShaderMaterial({
        vertexShader: mainVertexShader,
        fragmentShader: mainFragmentShader,
        uniforms: {
            u_polygon: { value: makeVec2Array(MAX_VERTICES) },
            u_vertexCount: { value: 0 },
            u_colorInside: { value: new THREE.Color(0x003366) },
            u_colorOutside: { value: new THREE.Color(0xffa500) },
            u_colorBoundary: { value: new THREE.Color(0xffffff) },
            u_rangeInside: { value: 0.10 },
            u_rangeOutside: { value: 0.10 },
        }
    });
    backgroundPlane.material = mainShaderMaterial;

    const daCanvas = document.getElementById('da-canvas');
    const daRenderer = new THREE.WebGLRenderer({ canvas: daCanvas, antialias: true });
    daRenderer.setPixelRatio(window.devicePixelRatio);
    const daScene = new THREE.Scene();
    const daCamera = new THREE.OrthographicCamera(0, 1, 1, 0, -1, 1);
    const daPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1));
    daPlane.position.set(0.5, 0.5, 0);
    daScene.add(daPlane);
    const daFragmentShader = `
      varying vec2 v_uv;
      uniform vec2 u_polygon[${MAX_VERTICES}];
      uniform int u_vertexCount;
      uniform float u_segmentLengths[${MAX_VERTICES}];
      uniform float u_totalPerimeter;
      ${commonGlslFunctions}
      void main() {
          float d = v_uv.x;
          float a = v_uv.y;
          vec2 vA = getPointAt_glsl(a - d / 2.0, u_polygon, u_vertexCount,
                                   u_segmentLengths, u_totalPerimeter);
          vec2 vC = getPointAt_glsl(a + d / 2.0, u_polygon, u_vertexCount,
                                   u_segmentLengths, u_totalPerimeter);
          vec2 center = (vA + vC) / 2.0;
          vec2 halfDiag = (vC - vA) / 2.0;
          vec2 vB = center + vec2(-halfDiag.y, halfDiag.x);
          vec2 vD = center + vec2(halfDiag.y, -halfDiag.x);
          float sdB = signedDistance_glsl(vB, u_polygon, u_vertexCount);
          float sdD = signedDistance_glsl(vD, u_polygon, u_vertexCount);
          float error = sdB * sdB + sdD * sdD;
          float maxError = 0.1 * 0.1;
          float t = clamp(error / maxError, 0.0, 1.0);
          gl_FragColor = vec4(vec3(1.0 - t), 1.0);
      }`;
    const daShaderMaterial = new THREE.ShaderMaterial({
        vertexShader: mainVertexShader,
        fragmentShader: daFragmentShader,
        uniforms: {
            u_polygon: { value: makeVec2Array(MAX_VERTICES) },
            u_vertexCount: { value: 0 },
            u_segmentLengths: { value: makeFloatArray(MAX_VERTICES) },
            u_totalPerimeter: { value: 0.0 }
        }
    });
    daPlane.material = daShaderMaterial;
    const crosshairDaX = document.getElementById('crosshair-da-x');
    const crosshairDaY = document.getElementById('crosshair-da-y');
    
    // --- BD Error Plot Setup ---
    const bdCanvas = document.getElementById('bd-canvas');
    const bdOverlayCanvas = document.getElementById('bd-overlay-canvas');
    const bdRenderer = new THREE.WebGLRenderer(
        { canvas: bdCanvas, antialias: true, alpha: true }
    );
    bdRenderer.setPixelRatio(window.devicePixelRatio);
    bdRenderer.setClearColor(0x000000, 1);
    const bdRenderTarget = new THREE.WebGLRenderTarget(1024, 1024,
        { format: THREE.RGBAFormat }
    );
    bdRenderTarget.texture.minFilter = THREE.LinearFilter;
    bdRenderTarget.texture.magFilter = THREE.LinearFilter;
    bdRenderTarget.texture.generateMipmaps = false;
    const bdScene = new THREE.Scene();
    const bdPointScene = new THREE.Scene();
    const bdCamera = new THREE.OrthographicCamera(-1.5, 1.5, 1.5, -1.5, -1, 1);
    const bdBakeCamera = new THREE.OrthographicCamera(-1.5, 1.5, 1.5, -1.5,-1,1);
    bdBakeCamera.zoom = 1;
    bdBakeCamera.updateProjectionMatrix();
    const bdPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(3, 3),
        new THREE.MeshBasicMaterial({ map: bdRenderTarget.texture })
    );
    bdScene.add(bdPlane);
    const bdOverlayCtx = bdOverlayCanvas.getContext('2d');
    
    const bdMapVertexShader = `
        attribute vec2 ad;
        uniform vec2 u_polygon[${MAX_VERTICES}];
        uniform int u_vertexCount;
        uniform float u_segmentLengths[${MAX_VERTICES}];
        uniform float u_totalPerimeter;
        uniform float u_pointSize;
        ${commonGlslFunctions}
        void main() {
            float d = ad.x;
            float a = ad.y;
            vec2 vA = getPointAt_glsl(a - d / 2.0, u_polygon, u_vertexCount,
                                     u_segmentLengths, u_totalPerimeter);
            vec2 vC = getPointAt_glsl(a + d / 2.0, u_polygon, u_vertexCount,
                                     u_segmentLengths, u_totalPerimeter);
            vec2 center = (vA + vC) / 2.0;
            vec2 halfDiag = (vC - vA) / 2.0;
            vec2 vB = center + vec2(-halfDiag.y, halfDiag.x);
            vec2 vD = center + vec2(halfDiag.y, -halfDiag.x);
            float sdB = signedDistance_glsl(vB, u_polygon, u_vertexCount);
            float sdD = signedDistance_glsl(vD, u_polygon, u_vertexCount);
            gl_PointSize = u_pointSize;
            gl_Position = projectionMatrix * modelViewMatrix *
                vec4(sdB, sdD, 0.0, 1.0);
        }`;
    const bdMapFragmentShader = `
        precision mediump float;
        uniform float u_pointWeight;
        void main() {
            // map to [-1,1]^2, radius 0 at center → 1 at edge
            vec2 p = gl_PointCoord * 2.0 - 1.0;
            float r = length(p);
            // soft disc: smooth edge; value ~1 in center, 0 at r>=1
            float w = smoothstep(1.0, 0.0, r);
            // scale contribution; additive blend will accumulate these
            w *= u_pointWeight;
            gl_FragColor = vec4(vec3(w), w);
        }`;

    const samples = 1024;
    const numPoints = samples * samples;
    const ad_coords = new Float32Array(numPoints * 2);
    for (let i = 0, ad_idx = 0; i < samples; i++) {
        for (let j = 0; j < samples; j++) {
            ad_coords[ad_idx++] = i / (samples - 1);
            ad_coords[ad_idx++] = j / (samples - 1);
        }
    }
    const bdPointGeometry = new THREE.BufferGeometry();
    bdPointGeometry.setAttribute('ad', new THREE.BufferAttribute(ad_coords, 2));
    const positions = new Float32Array(numPoints * 3);
    bdPointGeometry.setAttribute('position',
                                 new THREE.BufferAttribute(positions, 3));
    bdPointGeometry.setDrawRange(0, numPoints);
    bdPointGeometry.boundingSphere =
        new THREE.Sphere(new THREE.Vector3(0, 0, 0), 2.0);
    const bdMapMaterial = new THREE.ShaderMaterial({
        uniforms: {
            u_polygon: { value: makeVec2Array(MAX_VERTICES) },
            u_vertexCount: { value: 0 },
            u_segmentLengths: { value: makeFloatArray(MAX_VERTICES) },
            u_totalPerimeter: { value: 0 },
            u_pointSize: { value: 3.0 },
            u_pointWeight: { value: 0.06 }
        },
        vertexShader: bdMapVertexShader,
        fragmentShader: bdMapFragmentShader,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        depthWrite: false,
        transparent: true
    });
    bdMapMaterial.opacity = 0.05;
    const bdPoints = new THREE.Points(bdPointGeometry, bdMapMaterial);
    bdPoints.frustumCulled = false;
    bdPointScene.add(bdPoints);

    bdRenderer.render(bdPointScene, bdCamera);

    function updateBdTexture() {
        const paddedPolygon = [...polygon];
        while (paddedPolygon.length < MAX_VERTICES) {
            paddedPolygon.push(new THREE.Vector2());
        }
        const paddedSegs = [...segmentLengths];
        while (paddedSegs.length < MAX_VERTICES) {
            paddedSegs.push(0.0);
        }

        bdMapMaterial.uniforms.u_polygon.value = paddedPolygon;
        bdMapMaterial.uniforms.u_vertexCount.value = polygon.length;
        bdMapMaterial.uniforms.u_segmentLengths.value = paddedSegs;
        bdMapMaterial.uniforms.u_totalPerimeter.value = totalPerimeter;

        const currentTarget = bdRenderer.getRenderTarget();
        bdRenderer.setRenderTarget(bdRenderTarget);
        bdRenderer.setClearColor(0x000000, 1);
        bdRenderer.clear();
        bdRenderer.render(bdPointScene, bdBakeCamera);
        bdRenderer.setRenderTarget(currentTarget);

        const bounds = computeBdBounds(128);
        autoFrameBD(bounds);
    }

    function computeBdBounds(sampleN = 128) {
        let minB = Infinity, maxB = -Infinity, minD = Infinity, maxD = -Infinity;
        for (let i = 0; i < sampleN; i++) {
            const d = i / (sampleN - 1);
            for (let j = 0; j < sampleN; j++) {
                const a = j / (sampleN - 1);
                const vA = getPointAt(a - d / 2.0);
                const vC = getPointAt(a + d / 2.0);
                const center = new THREE.Vector2((vA.x + vC.x) / 2, (vA.y + vC.y) / 2);
                const halfD  = new THREE.Vector2((vC.x - vA.x) / 2, (vC.y - vA.y) / 2);
                const vB = new THREE.Vector2(center.x - halfD.y, center.y + halfD.x);
                const vD = new THREE.Vector2(center.x + halfD.y, center.y - halfD.x);
                const sdB = signedDistance(vB, polygon);
                const sdD = signedDistance(vD, polygon);
                if (sdB < minB) minB = sdB; if (sdB > maxB) maxB = sdB;
                if (sdD < minD) minD = sdD; if (sdD > maxD) maxD = sdD;
            }
        }
        return { minB, maxB, minD, maxD };
    }

    function autoFrameBD(bounds) {
        const padEachSide = 0.05;              // 5% per side → 10% total
        const w = 2*Math.max(Math.abs(bounds.minB), Math.abs(bounds.maxB));
        const h = 2*Math.max(Math.abs(bounds.minD), Math.abs(bounds.maxD));
        const size = Math.max(w, h) || 1;      // avoid div-by-zero
        const targetSpan = size * (1 + 2 * padEachSide); // ≈ 1.10 * size
        const viewSpan = (bdCamera.right - bdCamera.left); // = 3
        bdCamera.zoom = Math.max(0.1, viewSpan / targetSpan);
        bdCamera.position.set(0, 0, bdCamera.position.z);
        bdCamera.updateProjectionMatrix();
        drawBdOverlay(null);
    }
    
    function drawBdOverlay(d, current_sdB, current_sdD) {
        const w = bdOverlayCanvas.width;
        const h = bdOverlayCanvas.height;
        const halfW = 0.5 * (bdCamera.right - bdCamera.left) / bdCamera.zoom;
        const halfH = 0.5 * (bdCamera.top - bdCamera.bottom) / bdCamera.zoom;
        const left   = bdCamera.position.x - halfW;
        const right  = bdCamera.position.x + halfW;
        const bottom = bdCamera.position.y - halfH;
        const top    = bdCamera.position.y + halfH;
        bdOverlayCtx.clearRect(0, 0, w, h);
        bdOverlayCtx.strokeStyle = 'rgba(75, 85, 99, 1)';
        bdOverlayCtx.lineWidth = 1;
        bdOverlayCtx.beginPath();
        bdOverlayCtx.moveTo(w / 2, 0);
        bdOverlayCtx.lineTo(w / 2, h);
        bdOverlayCtx.stroke();
        bdOverlayCtx.beginPath();
        bdOverlayCtx.moveTo(0, h / 2);
        bdOverlayCtx.lineTo(w, h / 2);
        bdOverlayCtx.stroke();
        if (d === null) return;

        bdOverlayCtx.beginPath();
        const loopSamples = 1024;
        for (let i = 0; i <= loopSamples; i++) {
            const a = i / loopSamples;
            const vA = getPointAt(a - d / 2);
            const vC = getPointAt(a + d / 2);
            const center = new THREE.Vector2((vA.x + vC.x) / 2,
                                             (vA.y + vC.y) / 2);
            const halfD = new THREE.Vector2((vC.x - vA.x) / 2,
                                            (vC.y - vA.y) / 2);
            const vB = new THREE.Vector2(center.x - halfD.y,
                                         center.y + halfD.x);
            const vD = new THREE.Vector2(center.x + halfD.y,
                                         center.y - halfD.x);
            const sdB = signedDistance(vB, polygon);
            const sdD = signedDistance(vD, polygon);
            const px = ((sdB - left) / (right - left)) * w;
            const py = (1 - ((sdD - bottom) / (top - bottom))) * h;
            if (i === 0) bdOverlayCtx.moveTo(px, py);
            else bdOverlayCtx.lineTo(px, py);
        }
        bdOverlayCtx.strokeStyle = 'green';
        bdOverlayCtx.lineWidth = 1.5;
        bdOverlayCtx.stroke();

        bdOverlayCtx.strokeStyle = 'red';
        bdOverlayCtx.lineWidth = 1;
        const cross_px = ((current_sdB - left) / (right - left)) * w;
        const cross_py = (1 - ((current_sdD-bottom) / (top-bottom))) * h;
        bdOverlayCtx.beginPath();
        bdOverlayCtx.moveTo(cross_px, 0);
        bdOverlayCtx.lineTo(cross_px, h);
        bdOverlayCtx.stroke();
        bdOverlayCtx.beginPath();
        bdOverlayCtx.moveTo(0, cross_py);
        bdOverlayCtx.lineTo(w, cross_py);
        bdOverlayCtx.stroke();
    }
    function updatePerimeter() {
        totalPerimeter = 0;
        segmentLengths.length = 0;
        for (let i = 0; i < polygon.length; i++) {
            const p1 = polygon[i];
            const p2 = polygon[(i + 1) % polygon.length];
            const length = p1.distanceTo(p2);
            segmentLengths.push(length);
            totalPerimeter += length;
        }
    }
    function getPointAt(t) {
        if (totalPerimeter === 0) return polygon[0].clone();
        let targetDist = (t % 1.0) * totalPerimeter;
        if (targetDist < 0) targetDist += totalPerimeter;
        for (let i = 0; i < polygon.length; i++) {
            const segLen = segmentLengths[i];
            if (targetDist <= segLen && segLen > 0) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % polygon.length];
                return new THREE.Vector2().lerpVectors(p1, p2,
                    targetDist / segLen);
            }
            targetDist -= segLen;
        }
        return polygon[0].clone();
    }
    function isPointInside(point, poly) {
        let isInside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const p1 = poly[i];
            const p2 = poly[j];
            const intersect = ((p1.y > point.y) !== (p2.y > point.y)) &&
                (point.x < (p2.x - p1.x) * (point.y - p1.y) /
                 (p2.y - p1.y) + p1.x);
            if (intersect) isInside = !isInside;
        }
        return isInside;
    }
    function signedDistance(point, poly) {
        if (poly.length < 3) return 1.0;
        let minDistance = Infinity;
        for (let i = 0; i < poly.length; i++) {
            const p1 = poly[i];
            const p2 = poly[(i + 1) % poly.length];
            minDistance = Math.min(minDistance,
                                   distanceToSegment(point, p1, p2));
        }
        return isPointInside(point, poly) ? -minDistance : minDistance;
    }
    function updateLineAndPerimeter() {
        const p3 = polygon.map((p) => new THREE.Vector3(p.x, p.y, 0));
        line.geometry.setFromPoints(p3);
        updatePerimeter();
    }
    function rebuildVertices() {
        while (vertexMeshes.length > polygon.length)
            scene.remove(vertexMeshes.pop());
        while (vertexMeshes.length < polygon.length) {
            const m = new THREE.Mesh(vertexGeometry,
                new THREE.MeshBasicMaterial({ color: baseColor }));
            m.renderOrder = 1;
            vertexMeshes.push(m);
            scene.add(m);
        }
        vertexMeshes.forEach((mesh, index) => {
            const p = polygon[index];
            mesh.position.set(p.x, p.y, 0);
            const isSel = index === selectedVertexIndex;
            mesh.material.color.copy(isSel ? highlightColor : baseColor);
            mesh.scale.set(isSel ? 1.4 : 1.0, isSel ? 1.4 : 1.0, 1);
        });
    }

    function handleDAHover(event) {
      const rect = daCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const d = x / rect.width;
      const a = 1 - (y / rect.height);
      crosshairDaX.style.display = 'block';
      crosshairDaY.style.display = 'block';
      crosshairDaX.style.left = `${x}px`;
      crosshairDaY.style.top = `${y}px`;
      const vA = getPointAt(a - d / 2);
      const vC = getPointAt(a + d / 2);
      chordLine.geometry.setFromPoints(
          [new THREE.Vector3(vA.x, vA.y, 0), new THREE.Vector3(vC.x, vC.y, 0)]
      );
      chordLine.visible = true;
      const center = new THREE.Vector2((vA.x + vC.x) / 2, (vA.y + vC.y) / 2);
      const halfD = new THREE.Vector2((vC.x - vA.x) / 2, (vC.y - vA.y) / 2);
      const vB = new THREE.Vector2(center.x - halfD.y, center.y + halfD.x);
      const vD = new THREE.Vector2(center.x + halfD.y, center.y - halfD.x);
      squareLine.geometry.setFromPoints([
          new THREE.Vector3(vA.x, vA.y, 0), new THREE.Vector3(vB.x, vB.y, 0),
          new THREE.Vector3(vC.x, vC.y, 0), new THREE.Vector3(vD.x, vD.y, 0)
      ]);
      squareLine.visible = true;
      sqVtxB.position.set(vB.x, vB.y, 0);
      sqVtxD.position.set(vD.x, vD.y, 0);
      sqVtxB.visible = true;
      sqVtxD.visible = true;
      drawBdOverlay(d, signedDistance(vB, polygon),
                    signedDistance(vD, polygon));
    }
    daCanvas.addEventListener('pointermove', handleDAHover);
    daCanvas.addEventListener('pointercenter', handleDAHover);

    daCanvas.addEventListener('pointerleave', () => {
      chordLine.visible = false;
      squareLine.visible = false;
      sqVtxB.visible = false;
      sqVtxD.visible = false;
      crosshairDaX.style.display = 'none';
      crosshairDaY.style.display = 'none';
      drawBdOverlay(null);
    });
    
    function getPointerPosition(event) {
        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) / rect.width;
        const y = 1 - (event.clientY - rect.top) / rect.height;
        return new THREE.Vector2(x, y);
    }
    function trySelectVertex(pos) {
        const threshold = 0.03;
        let closestIndex = null;
        let closestDistance = Infinity;
        polygon.forEach((vertex, index) => {
            const d = vertex.distanceTo(pos);
            if (d < threshold && d < closestDistance) {
                closestDistance = d;
                closestIndex = index;
            }
        });
        if (closestIndex !== null) {
            selectedVertexIndex = closestIndex;
            rebuildVertices();
            return true;
        }
        return false;
    }
    function distanceToSegment(point, a, b) {
        const ab = new THREE.Vector2().subVectors(b, a);
        const ap = new THREE.Vector2().subVectors(point, a);
        const t = Math.max(0, Math.min(1, ap.dot(ab) / ab.lengthSq()));
        const closest = new THREE.Vector2().copy(a).add(ab.multiplyScalar(t));
        return closest.distanceTo(point);
    }
    function tryInsertVertexOnEdge(pos) {
        const threshold = 0.02;
        for (let i = 0; i < polygon.length; i += 1) {
            const nextIndex = (i + 1) % polygon.length;
            const dist=distanceToSegment(pos, polygon[i], polygon[nextIndex]);
            if (dist < threshold) {
                polygon.splice(nextIndex, 0, pos.clone());
                selectedVertexIndex = nextIndex;
                rebuildVertices();
                updateLineAndPerimeter();
                bdDirty = true;
                return true;
            }
        }
        return false;
    }
    function clampPoint(p) {
        p.x = Math.min(Math.max(p.x, 0), 1);
        p.y = Math.min(Math.max(p.y, 0), 1);
    }
    function getOrientation(p, q, r) {
        const v = (q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);
        if (Math.abs(v) < 1e-5) return 0;
        return (v > 0) ? 1 : 2;
    }
    function segmentsIntersect(p1, q1, p2, q2) {
        const o1=getOrientation(p1,q1,p2);
        const o2=getOrientation(p1,q1,q2);
        const o3=getOrientation(p2,q2,p1);
        const o4=getOrientation(p2,q2,q1);
        return (o1 !== o2 && o3 !== o4);
    }
    function isPolygonValid(poly) {
        const n = poly.length;
        if (n <= 3) return true;
        for (let i = 0; i < n; i++) {
            const p1 = poly[i];
            const q1 = poly[(i + 1) % n];
            for (let j = i + 2; j < n; j++) {
                if ((j + 1) % n === i) continue;
                const p2 = poly[j];
                const q2 = poly[(j + 1) % n];
                if (segmentsIntersect(p1, q1, p2, q2)) return false;
            }
        }
        return true;
    }

    canvas.addEventListener('pointerdown', (event) => {
        canvas.setPointerCapture(event.pointerId);
        const pos = getPointerPosition(event);
        if (trySelectVertex(pos) || tryInsertVertexOnEdge(pos)) {
            isDragging = true;
        } else {
            selectedVertexIndex = null;
            rebuildVertices();
        }
    });
    canvas.addEventListener('pointermove', (event) => {
        if (!isDragging || selectedVertexIndex === null) return;
        const pos = getPointerPosition(event);
        clampPoint(pos);
        const tempPolygon = polygon.map(p => p.clone());
        tempPolygon[selectedVertexIndex].copy(pos);
        if (isPolygonValid(tempPolygon)) {
            polygon[selectedVertexIndex].copy(pos);
            vertexMeshes[selectedVertexIndex].position.set(pos.x, pos.y, 0);
            updateLineAndPerimeter();
            bdDirty = true;
        }
    });
    function endDrag(event) {
        if (event) canvas.releasePointerCapture(event.pointerId);
        if (isDragging) bdDirty = true;
        isDragging = false;
    }
    canvas.addEventListener('pointerup', endDrag);
    canvas.addEventListener('pointerleave', endDrag);
    function deleteSelectedVertex() {
        if (selectedVertexIndex === null || polygon.length <= 3) return;
        polygon.splice(selectedVertexIndex, 1);
        selectedVertexIndex = null;
        rebuildVertices();
        updateLineAndPerimeter();
        bdDirty = true;
    }
    window.addEventListener('keydown', (e) => {
        if (e.key === 'Delete' || e.key === 'Backspace') deleteSelectedVertex();
    });

    function renderLoop() {
        const paddedPolygon = [...polygon];
        while (paddedPolygon.length < MAX_VERTICES) {
            paddedPolygon.push(new THREE.Vector2());
        }
        const paddedSegs = [...segmentLengths];
        while (paddedSegs.length < MAX_VERTICES) {
            paddedSegs.push(0.0);
        }
        
        mainShaderMaterial.uniforms.u_polygon.value = paddedPolygon;
        mainShaderMaterial.uniforms.u_vertexCount.value = polygon.length;
        
        daShaderMaterial.uniforms.u_polygon.value = paddedPolygon;
        daShaderMaterial.uniforms.u_vertexCount.value = polygon.length;
        daShaderMaterial.uniforms.u_segmentLengths.value = paddedSegs;
        daShaderMaterial.uniforms.u_totalPerimeter.value = totalPerimeter;

        if (bdDirty) {
            updateBdTexture();
            bdDirty = false;
        }

        renderer.render(scene, camera);
        daRenderer.render(daScene, daCamera);
        bdRenderer.render(bdScene, bdCamera);
    }

    function onResize() {
        document.querySelectorAll('.plot-container').forEach(container => {
            const { width } = container.getBoundingClientRect();
            const canvas = container.querySelector('canvas');
            if (canvas.id === 'da-canvas')
                daRenderer.setSize(width, width, false);
            else if (canvas.id === 'bd-canvas') {
                bdRenderer.setSize(width, width, false);
                bdOverlayCanvas.width = bdOverlayCanvas.height = width;
            } else if (canvas.id === 'vis-canvas')
                renderer.setSize(width, width, false);
        });
        bdDirty = true;
        drawBdOverlay(null);
    }
    window.addEventListener('resize', onResize);

    updateLineAndPerimeter();
    rebuildVertices();
    onResize();
    renderer.setAnimationLoop(renderLoop);

  </script>
</body>
</html>

