<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Polygon Visualizer</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js"
      }
    }
  </script>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #f5f7fb, #d7dce5);
      color: #1f2933;
    }

    .wrapper {
      text-align: center;
      padding: 1.5rem;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.85);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.15);
      backdrop-filter: blur(10px);
    }

    h1 {
      margin-top: 0;
      font-weight: 600;
      letter-spacing: 0.04em;
    }

    .plots-wrapper {
      display: flex;
      gap: 1.5rem;
      align-items: center;
      justify-content: center;
    }

    .plot-container {
      position: relative;
      width: min(300px, 28vw);
      aspect-ratio: 1 / 1;
    }

    .canvas-container {
      border-radius: 16px;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.08);
      background: #101827;
      width: 100%;
      height: 100%;
    }

    .bd-plot-container canvas {
        position: absolute;
        top: 0;
        left: 0;
    }

    #da-canvas, #bd-canvas, #bd-overlay-canvas {
      border-radius: 16px;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
    }

    .controls {
      margin-top: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: center;
    }

    .hint {
      margin: 0;
      max-width: 420px;
      font-size: 0.9rem;
      color: #475569;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>Polygon Playground</h1>
    <div class="plots-wrapper">
      <div class="plot-container">
        <div class="canvas-container">
          <canvas id="vis-canvas"></canvas>
        </div>
      </div>
      <div class="plot-container">
        <canvas id="da-canvas"></canvas>
      </div>
       <div class="plot-container bd-plot-container">
        <canvas id="bd-canvas"></canvas>
        <canvas id="bd-overlay-canvas"></canvas>
      </div>
    </div>
    <div class="controls">
      <p class="hint">
        Drag a vertex to move it. Click an edge to create a new vertex.
        Click a vertex and press delete to remove it.
      </p>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';

    // --- Main Polygon Visualization Setup ---
    const canvas = document.getElementById('vis-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f172a);
    const camera = new THREE.OrthographicCamera(0, 1, 1, 0, -10, 10);
    camera.position.set(0, 0, 5);
    const backgroundPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1));
    backgroundPlane.position.set(0.5, 0.5, -1);
    backgroundPlane.renderOrder = -1;
    scene.add(backgroundPlane);

    const polygon = [
      new THREE.Vector2(0.25, 0.25), new THREE.Vector2(0.75, 0.25),
      new THREE.Vector2(0.75, 0.75), new THREE.Vector2(0.25, 0.75)
    ];

    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
    const line = new THREE.LineLoop(new THREE.BufferGeometry(), lineMaterial);
    scene.add(line);

    // --- Chord and Square Visualization Setup ---
    const chordMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const chordLine = new THREE.Line(new THREE.BufferGeometry(), chordMaterial);
    chordLine.visible = false;
    scene.add(chordLine);
    const squareMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
    const squareLine = new THREE.LineLoop(new THREE.BufferGeometry(), squareMaterial);
    squareLine.visible = false;
    scene.add(squareLine);
    const otherVertexGeometry = new THREE.RingGeometry(0.008, 0.012, 24);
    const otherVertexMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    const squareVertexB_mesh = new THREE.Mesh(otherVertexGeometry, otherVertexMaterial);
    const squareVertexD_mesh = new THREE.Mesh(otherVertexGeometry, otherVertexMaterial);
    squareVertexB_mesh.visible = false; squareVertexD_mesh.visible = false;
    scene.add(squareVertexB_mesh, squareVertexD_mesh);

    const vertexGeometry = new THREE.CircleGeometry(0.015, 24);
    const baseColor = new THREE.Color(0x3b82f6);
    const highlightColor = new THREE.Color(0xf97316);
    const vertexMeshes = [];

    let selectedVertexIndex = null;
    let isDragging = false;
    let totalPerimeter = 0;
    const segmentLengths = [];

    const MAX_VERTICES = 50;
    const mainVertexShader = `varying vec2 v_uv; void main() { v_uv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
    const commonGlslFunctions = `
      float distanceToSegment(vec2 p, vec2 a, vec2 b) { vec2 ab = b - a; vec2 ap = p - a; float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0); return distance(p, a + t * ab); }
      float signedDistance_glsl(vec2 p, vec2 poly[${MAX_VERTICES}], int count) { if (count < 3) return 1.0; float minDst = 1e9; for (int i = 0; i < ${MAX_VERTICES}; ++i) { if (i >= count) break; vec2 p1 = poly[i]; vec2 p2 = poly[int(mod(float(i) + 1.0, float(count)))]; minDst = min(minDst, distanceToSegment(p, p1, p2)); } const float PI = 3.1415926535; float totalAngle = 0.0; for (int i = 0; i < ${MAX_VERTICES}; ++i) { if (i >= count) break; vec2 v1 = poly[i] - p; vec2 v2 = poly[int(mod(float(i)+1.0, float(count)))] - p; float angle1 = atan(v1.y, v1.x); float angle2 = atan(v2.y, v2.x); float deltaAngle = angle2 - angle1; if (deltaAngle > PI) deltaAngle -= 2.0 * PI; if (deltaAngle < -PI) deltaAngle += 2.0 * PI; totalAngle += deltaAngle; } return abs(totalAngle) > PI ? -minDst : minDst; }
      vec2 getPointAt_glsl(float t, vec2 poly[${MAX_VERTICES}], int count, float segs[${MAX_VERTICES}], float totalPerim) { if (totalPerim == 0.0) return poly[0]; float targetDist = mod(t, 1.0) * totalPerim; for (int i = 0; i < ${MAX_VERTICES}; ++i) { if (i >= count) break; float segLen = segs[i]; if (targetDist <= segLen && segLen > 0.0) { vec2 p1 = poly[i]; vec2 p2 = poly[int(mod(float(i) + 1.0, float(count)))]; return mix(p1, p2, targetDist / segLen); } targetDist -= segLen; } return poly[0]; }
    `;
    const mainFragmentShader = `
      varying vec2 v_uv; uniform vec2 u_polygon[${MAX_VERTICES}]; uniform int u_vertexCount; uniform vec3 u_colorInside; uniform vec3 u_colorOutside; uniform vec3 u_colorBoundary; uniform float u_rangeInside; uniform float u_rangeOutside;
      ${commonGlslFunctions}
      void main() { float sd = signedDistance_glsl(v_uv, u_polygon, u_vertexCount); vec3 finalColor; if (sd >= 0.0) { float t = smoothstep(0.0, u_rangeOutside, sd); finalColor = mix(u_colorBoundary, u_colorOutside, t); } else { float t = smoothstep(0.0, u_rangeInside, -sd); finalColor = mix(u_colorBoundary, u_colorInside, t); } gl_FragColor = vec4(finalColor, 1.0); }`;
    const mainShaderMaterial = new THREE.ShaderMaterial({ vertexShader: mainVertexShader, fragmentShader: mainFragmentShader, uniforms: { u_polygon: { value: [] }, u_vertexCount: { value: 0 }, u_colorInside: { value: new THREE.Color(0x003366) }, u_colorOutside: { value: new THREE.Color(0xffa500) }, u_colorBoundary: { value: new THREE.Color(0xffffff) }, u_rangeInside: { value: 0.10 }, u_rangeOutside: { value: 0.10 }, } });
    backgroundPlane.material = mainShaderMaterial;

    const daCanvas = document.getElementById('da-canvas');
    const daRenderer = new THREE.WebGLRenderer({ canvas: daCanvas, antialias: true });
    daRenderer.setPixelRatio(window.devicePixelRatio);
    const daScene = new THREE.Scene();
    const daCamera = new THREE.OrthographicCamera(0, 1, 1, 0, -1, 1);
    const daPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1));
    daPlane.position.set(0.5, 0.5, 0); daScene.add(daPlane);
    const daFragmentShader = `
      varying vec2 v_uv; uniform vec2 u_polygon[${MAX_VERTICES}]; uniform int u_vertexCount; uniform float u_segmentLengths[${MAX_VERTICES}]; uniform float u_totalPerimeter;
      ${commonGlslFunctions}
      void main() { float d = v_uv.x; float a = v_uv.y; vec2 vA = getPointAt_glsl(a, u_polygon, u_vertexCount, u_segmentLengths, u_totalPerimeter); vec2 vC = getPointAt_glsl(a + d, u_polygon, u_vertexCount, u_segmentLengths, u_totalPerimeter); vec2 center = (vA + vC) / 2.0; vec2 halfDiag = (vC - vA) / 2.0; vec2 vB = center + vec2(-halfDiag.y, halfDiag.x); vec2 vD = center + vec2(halfDiag.y, -halfDiag.x); float sdB = signedDistance_glsl(vB, u_polygon, u_vertexCount); float sdD = signedDistance_glsl(vD, u_polygon, u_vertexCount); float error = sdB * sdB + sdD * sdD; float maxError = 0.1 * 0.1; float t = clamp(error / maxError, 0.0, 1.0); gl_FragColor = vec4(vec3(1.0 - t), 1.0); }`;
    const daShaderMaterial = new THREE.ShaderMaterial({ vertexShader: mainVertexShader, fragmentShader: daFragmentShader, uniforms: { u_polygon: { value: [] }, u_vertexCount: { value: 0 }, u_segmentLengths: { value: [] }, u_totalPerimeter: { value: 0.0 } } });
    daPlane.material = daShaderMaterial;
    
    // --- BD Error Plot Setup ---
    const bdCanvas = document.getElementById('bd-canvas');
    const bdOverlayCanvas = document.getElementById('bd-overlay-canvas');
    const bdRenderer = new THREE.WebGLRenderer({ canvas: bdCanvas, antialias: true });
    bdRenderer.setPixelRatio(window.devicePixelRatio);
    const bdScene = new THREE.Scene();
    const bdCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
    const bdPlane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2));
    bdScene.add(bdPlane);
    const bdOverlayCtx = bdOverlayCanvas.getContext('2d');
    let bdErrorRange = 0.1;
    const bdTextureSize = 256;
    const bdData = new Uint8Array(bdTextureSize * bdTextureSize * 4);
    const bdDataTexture = new THREE.DataTexture(bdData, bdTextureSize, bdTextureSize, THREE.RGBAFormat, THREE.UnsignedByteType);
    const bdFragmentShader = `varying vec2 v_uv; uniform sampler2D u_bd_map; void main() { gl_FragColor = texture2D(u_bd_map, v_uv); }`;
    const bdShaderMaterial = new THREE.ShaderMaterial({ vertexShader: mainVertexShader, fragmentShader: bdFragmentShader, uniforms: { u_bd_map: { value: bdDataTexture } } });
    bdPlane.material = bdShaderMaterial;

function updateBdDataTexture() {
  // 1) build a hit histogram (sum of all green curves)
  const w = bdTextureSize;
  const h = bdTextureSize;
  const counts = new Uint32Array(w * h);

  // clear target texture buffer
  for (let i = 0; i < bdData.length; i += 4) {
    bdData[i] = 0;
    bdData[i + 1] = 0;
    bdData[i + 2] = 0;
    bdData[i + 3] = 255;
  }

  const samples = 512;
  for (let d_idx = 0; d_idx < samples; d_idx++) {
    const d = d_idx / (samples - 1);
    for (let a_idx = 0; a_idx < samples; a_idx++) {
      const a = a_idx / (samples - 1);

      const vA = getPointAt(a);
      const vC = getPointAt((a + d) % 1.0);

      const center = new THREE.Vector2(
        (vA.x + vC.x) / 2,
        (vA.y + vC.y) / 2
      );
      const halfDiag = new THREE.Vector2(
        (vC.x - vA.x) / 2,
        (vC.y - vA.y) / 2
      );

      const vB = new THREE.Vector2(
        center.x - halfDiag.y,
        center.y + halfDiag.x
      );
      const vD = new THREE.Vector2(
        center.x + halfDiag.y,
        center.y - halfDiag.x
      );

      const sdB = signedDistance(vB, polygon);
      const sdD = signedDistance(vD, polygon);

      const normX = sdB / bdErrorRange;
      const normY = sdD / bdErrorRange;

      if (Math.abs(normX) <= 1 && Math.abs(normY) <= 1) {
        const px = Math.floor((normX * 0.5 + 0.5) * (w - 1));
        const py = Math.floor((normY * 0.5 + 0.5) * (h - 1));
        counts[py * w + px] += 1;
      }
    }
  }

  // 2) normalize histogram to grayscale for the DataTexture
  let maxCount = 0;
  for (let i = 0; i < counts.length; i++) {
    if (counts[i] > maxCount) maxCount = counts[i];
  }

  if (maxCount > 0) {
    for (let i = 0; i < counts.length; i++) {
      // sqrt for better contrast on sparse data
      const v = Math.floor(
        255 * Math.sqrt(counts[i] / maxCount)
      );
      const idx = i * 4;
      bdData[idx] = v;
      bdData[idx + 1] = v;
      bdData[idx + 2] = v;
      // alpha already set to 255
    }
  }

  bdDataTexture.needsUpdate = true;
}


    function updateBdErrorRange() {
        let maxAbsError = 0.0; const samples = 50; 
        for (let i = 0; i < samples; i++) {
            for (let j = 0; j < samples; j++) {
                const d = i / (samples - 1); const a = j / (samples - 1);
                const vA = getPointAt(a); const vC = getPointAt((a + d) % 1.0);
                const center = new THREE.Vector2((vA.x + vC.x) / 2, (vA.y + vC.y) / 2);
                const halfDiag = new THREE.Vector2((vC.x - vA.x) / 2, (vC.y - vA.y) / 2);
                const vB = new THREE.Vector2(center.x - halfDiag.y, center.y + halfDiag.x);
                const vD = new THREE.Vector2(center.x + halfDiag.y, center.y - halfDiag.x);
                const sdB = signedDistance(vB, polygon); const sdD = signedDistance(vD, polygon);
                maxAbsError = Math.max(maxAbsError, Math.abs(sdB), Math.abs(sdD));
            }
        }
        bdErrorRange = maxAbsError > 1e-5 ? maxAbsError * 1.1 : 0.1;
        bdCamera.left = -bdErrorRange; bdCamera.right = bdErrorRange;
        bdCamera.top = bdErrorRange; bdCamera.bottom = -bdErrorRange;
        bdCamera.updateProjectionMatrix();
        updateBdDataTexture();
    }

    function drawBdOverlay(d, current_sdB, current_sdD) {
        const w = bdOverlayCanvas.width; const h = bdOverlayCanvas.height;
        bdOverlayCtx.clearRect(0, 0, w, h);
        bdOverlayCtx.strokeStyle = 'rgba(75, 85, 99, 1)'; bdOverlayCtx.lineWidth = 1;
        bdOverlayCtx.beginPath(); bdOverlayCtx.moveTo(w / 2, 0); bdOverlayCtx.lineTo(w / 2, h); bdOverlayCtx.stroke();
        bdOverlayCtx.beginPath(); bdOverlayCtx.moveTo(0, h / 2); bdOverlayCtx.lineTo(w, h / 2); bdOverlayCtx.stroke();
        if (d === null) return;

        bdOverlayCtx.beginPath();
        const samples = 200;
        for (let i = 0; i <= samples; i++) {
            const a = i / samples; const vA = getPointAt(a); const vC = getPointAt((a + d) % 1.0);
            const center = new THREE.Vector2((vA.x + vC.x) / 2, (vA.y + vC.y) / 2);
            const halfDiag = new THREE.Vector2((vC.x - vA.x) / 2, (vC.y - vA.y) / 2);
            const vB = new THREE.Vector2(center.x - halfDiag.y, center.y + halfDiag.x); const vD = new THREE.Vector2(center.x + halfDiag.y, center.y - halfDiag.x);
            const sdB = signedDistance(vB, polygon); const sdD = signedDistance(vD, polygon);
            const px = (sdB / (2 * bdErrorRange) + 0.5) * w; const py = (1 - (sdD / (2 * bdErrorRange) + 0.5)) * h;
            if (i === 0) bdOverlayCtx.moveTo(px, py); else bdOverlayCtx.lineTo(px, py);
        }
        bdOverlayCtx.strokeStyle = 'green'; bdOverlayCtx.lineWidth = 1.5; bdOverlayCtx.stroke();

        bdOverlayCtx.strokeStyle = 'red'; bdOverlayCtx.lineWidth = 1;
        const cross_px = (current_sdB / (2 * bdErrorRange) + 0.5) * w; const cross_py = (1 - (current_sdD / (2 * bdErrorRange) + 0.5)) * h;
        bdOverlayCtx.beginPath(); bdOverlayCtx.moveTo(cross_px, 0); bdOverlayCtx.lineTo(cross_px, h); bdOverlayCtx.stroke();
        bdOverlayCtx.beginPath(); bdOverlayCtx.moveTo(0, cross_py); bdOverlayCtx.lineTo(w, cross_py); bdOverlayCtx.stroke();
    }

    function updatePerimeter() { totalPerimeter = 0; segmentLengths.length = 0; for (let i = 0; i < polygon.length; i++) { const p1 = polygon[i]; const p2 = polygon[(i + 1) % polygon.length]; const length = p1.distanceTo(p2); segmentLengths.push(length); totalPerimeter += length; } }
    function getPointAt(t) { if (totalPerimeter === 0) return polygon[0].clone(); let targetDist = (t % 1.0) * totalPerimeter; if (targetDist < 0) targetDist += totalPerimeter; for (let i = 0; i < polygon.length; i++) { const segLen = segmentLengths[i]; if (targetDist <= segLen && segLen > 0) { const p1 = polygon[i]; const p2 = polygon[(i + 1) % polygon.length]; return new THREE.Vector2().lerpVectors(p1, p2, targetDist / segLen); } targetDist -= segLen; } return polygon[0].clone(); }
    function isPointInside(point, poly) { let isInside = false; for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) { const p1 = poly[i]; const p2 = poly[j]; const intersect = ((p1.y > point.y) !== (p2.y > point.y)) && (point.x < (p2.x - p1.x) * (point.y - p1.y) / (p2.y - p1.y) + p1.x); if (intersect) isInside = !isInside; } return isInside; }
    function signedDistance(point, poly) { if (poly.length < 3) return 1.0; let minDistance = Infinity; for (let i = 0; i < poly.length; i++) { const p1 = poly[i]; const p2 = poly[(i + 1) % poly.length]; minDistance = Math.min(minDistance, distanceToSegment(point, p1, p2)); } return isPointInside(point, poly) ? -minDistance : minDistance; }
    function updateLineAndPerimeter() { const points3 = polygon.map((p) => new THREE.Vector3(p.x, p.y, 0)); line.geometry.setFromPoints(points3); updatePerimeter(); }
    function rebuildVertices() { while (vertexMeshes.length > polygon.length) scene.remove(vertexMeshes.pop()); while (vertexMeshes.length < polygon.length) { const mesh = new THREE.Mesh(vertexGeometry, new THREE.MeshBasicMaterial({ color: baseColor })); mesh.renderOrder = 1; vertexMeshes.push(mesh); scene.add(mesh); } vertexMeshes.forEach((mesh, index) => { const point = polygon[index]; mesh.position.set(point.x, point.y, 0); const isSelected = index === selectedVertexIndex; mesh.material.color.copy(isSelected ? highlightColor : baseColor); mesh.scale.set(isSelected ? 1.4 : 1.0, isSelected ? 1.4 : 1.0, 1); }); }

    daCanvas.addEventListener('pointermove', (event) => {
      const rect = daCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left; const y = event.clientY - rect.top;
      const d = x / rect.width; const a = 1 - (y / rect.height);
      const vA = getPointAt(a); const vC = getPointAt((a + d) % 1.0);
      chordLine.geometry.setFromPoints([ new THREE.Vector3(vA.x, vA.y, 0), new THREE.Vector3(vC.x, vC.y, 0) ]);
      chordLine.visible = true;
      const center = new THREE.Vector2((vA.x + vC.x) / 2, (vA.y + vC.y) / 2);
      const halfDiag = new THREE.Vector2((vC.x - vA.x) / 2, (vC.y - vA.y) / 2);
      const vB = new THREE.Vector2(center.x - halfDiag.y, center.y + halfDiag.x);
      const vD = new THREE.Vector2(center.x + halfDiag.y, center.y - halfDiag.x);
      squareLine.geometry.setFromPoints([ new THREE.Vector3(vA.x, vA.y, 0), new THREE.Vector3(vB.x, vB.y, 0), new THREE.Vector3(vC.x, vC.y, 0), new THREE.Vector3(vD.x, vD.y, 0) ]);
      squareLine.visible = true;
      squareVertexB_mesh.position.set(vB.x, vB.y, 0); squareVertexD_mesh.position.set(vD.x, vD.y, 0);
      squareVertexB_mesh.visible = true; squareVertexD_mesh.visible = true;
      drawBdOverlay(d, signedDistance(vB, polygon), signedDistance(vD, polygon));
    });

    daCanvas.addEventListener('pointerleave', () => {
      chordLine.visible = false; squareLine.visible = false;
      squareVertexB_mesh.visible = false; squareVertexD_mesh.visible = false;
      drawBdOverlay(null);
    });

    function getPointerPosition(event) { const rect = canvas.getBoundingClientRect(); const x = (event.clientX - rect.left) / rect.width; const y = 1 - (event.clientY - rect.top) / rect.height; return new THREE.Vector2(x, y); }
    function trySelectVertex(pos) { const threshold = 0.03; let closestIndex = null; let closestDistance = Infinity; polygon.forEach((vertex, index) => { const d = vertex.distanceTo(pos); if (d < threshold && d < closestDistance) { closestDistance = d; closestIndex = index; } }); if (closestIndex !== null) { selectedVertexIndex = closestIndex; rebuildVertices(); return true; } return false; }
    function distanceToSegment(point, a, b) { const ab = new THREE.Vector2().subVectors(b, a); const ap = new THREE.Vector2().subVectors(point, a); const t = Math.max(0, Math.min(1, ap.dot(ab) / ab.lengthSq())); const closest = new THREE.Vector2().copy(a).add(ab.multiplyScalar(t)); return closest.distanceTo(point); }
    function tryInsertVertexOnEdge(pos) { const threshold = 0.02; for (let i = 0; i < polygon.length; i += 1) { const nextIndex = (i + 1) % polygon.length; const dist = distanceToSegment(pos, polygon[i], polygon[nextIndex]); if (dist < threshold) { polygon.splice(nextIndex, 0, pos.clone()); selectedVertexIndex = nextIndex; rebuildVertices(); updateLineAndPerimeter(); updateBdErrorRange(); return true; } } return false; }
    function clampPoint(point) { point.x = Math.min(Math.max(point.x, 0), 1); point.y = Math.min(Math.max(point.y, 0), 1); }
    function getOrientation(p, q, r) { const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); if (Math.abs(val) < 1e-5) return 0; return (val > 0) ? 1 : 2; }
    function segmentsIntersect(p1, q1, p2, q2) { const o1 = getOrientation(p1, q1, p2); const o2 = getOrientation(p1, q1, q2); const o3 = getOrientation(p2, q2, p1); const o4 = getOrientation(p2, q2, q1); return (o1 !== o2 && o3 !== o4); }
    function isPolygonValid(poly) { const n = poly.length; if (n <= 3) return true; for (let i = 0; i < n; i++) { const p1 = poly[i]; const q1 = poly[(i + 1) % n]; for (let j = i + 2; j < n; j++) { if ((j + 1) % n === i) continue; const p2 = poly[j]; const q2 = poly[(j + 1) % n]; if (segmentsIntersect(p1, q1, p2, q2)) return false; } } return true; }

    canvas.addEventListener('pointerdown', (event) => { canvas.setPointerCapture(event.pointerId); const pos = getPointerPosition(event); if (trySelectVertex(pos) || tryInsertVertexOnEdge(pos)) { isDragging = true; } else { selectedVertexIndex = null; rebuildVertices(); } });
    canvas.addEventListener('pointermove', (event) => { if (!isDragging || selectedVertexIndex === null) return; const pos = getPointerPosition(event); clampPoint(pos); const tempPolygon = polygon.map(p => p.clone()); tempPolygon[selectedVertexIndex].copy(pos); if (isPolygonValid(tempPolygon)) { polygon[selectedVertexIndex].copy(pos); vertexMeshes[selectedVertexIndex].position.set(pos.x, pos.y, 0); updateLineAndPerimeter(); } });
    function endDrag(event) { if (event) canvas.releasePointerCapture(event.pointerId); if (isDragging) { updateBdErrorRange(); } isDragging = false; }
    canvas.addEventListener('pointerup', endDrag); canvas.addEventListener('pointerleave', endDrag);
    function deleteSelectedVertex() { if (selectedVertexIndex === null || polygon.length <= 3) return; polygon.splice(selectedVertexIndex, 1); selectedVertexIndex = null; rebuildVertices(); updateLineAndPerimeter(); updateBdErrorRange(); }
    window.addEventListener('keydown', (event) => { if (event.key === 'Delete' || event.key === 'Backspace') deleteSelectedVertex(); });

    function renderLoop() {
      const paddedPolygon = [...polygon]; while (paddedPolygon.length < MAX_VERTICES) paddedPolygon.push(new THREE.Vector2(0, 0));
      const paddedSegmentLengths = [...segmentLengths]; while (paddedSegmentLengths.length < MAX_VERTICES) paddedSegmentLengths.push(0.0);
      const uniforms = { u_polygon: paddedPolygon, u_vertexCount: polygon.length, u_segmentLengths: paddedSegmentLengths, u_totalPerimeter: totalPerimeter, };
      mainShaderMaterial.uniforms.u_polygon.value = uniforms.u_polygon; mainShaderMaterial.uniforms.u_vertexCount.value = uniforms.u_vertexCount;
      daShaderMaterial.uniforms.u_polygon.value = uniforms.u_polygon; daShaderMaterial.uniforms.u_vertexCount.value = uniforms.u_vertexCount; daShaderMaterial.uniforms.u_segmentLengths.value = uniforms.u_segmentLengths; daShaderMaterial.uniforms.u_totalPerimeter.value = uniforms.u_totalPerimeter;
      renderer.render(scene, camera);
      daRenderer.render(daScene, daCamera);
      bdRenderer.render(bdScene, bdCamera);
    }

    function onResize() {
      const plotContainers = document.querySelectorAll('.plot-container');
      plotContainers.forEach(container => {
        const { width } = container.getBoundingClientRect();
        const canvas = container.querySelector('canvas');
        if (canvas.id === 'da-canvas') daRenderer.setSize(width, width, false);
        else if (canvas.id === 'bd-canvas') { 
            bdRenderer.setSize(width, width, false);
            bdOverlayCanvas.width = bdOverlayCanvas.height = width;
        }
        else if (canvas.id === 'vis-canvas') renderer.setSize(width, width, false);
      });
      updateBdErrorRange();
    }
    window.addEventListener('resize', onResize);

    updateLineAndPerimeter(); rebuildVertices(); onResize();
    renderer.setAnimationLoop(renderLoop);

  </script>
</body>
</html>

